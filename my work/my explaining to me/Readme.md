prototype

JavaScript-ში ყველა ობიექტს აქვს პროტოტიპი. პროტოტიპი არსებითად არის ამ ობიექტის გეგმა ან შაბლონი, რომელიც განსაზღვრავს რომელ თვისებებსა და მეთოდებს მიიღებს ობიექტი.

როდესაც თქვენ წვდებით ობიექტის თვისებას ან მეთოდს, JavaScript ჯერ ამოწმებს, არის თუ არა ეს თვისება ან მეთოდი უშუალოდ თავად ობიექტზე. თუ ის ვერ პოულობს, ის ეძებს პროტოტიპის ჯაჭვს. პროტოტიპის ჯაჭვი არის დაკავშირებული ობიექტების სერია, სადაც თითოეულ ობიექტს აქვს მითითება მის პროტოტიპზე. ეს ჯაჭვი გრძელდება მანამ, სანამ არ მიაღწევს ბოლომდე, რომელიც ჩვეულებრივ არის Object.prototype JavaScript-ში.

პროტოტიპის თვისება არის მითითება ობიექტზე, საიდანაც სხვა ობიექტი მემკვიდრეობით იღებს თვისებებს. როდესაც ქმნით ობიექტს კონსტრუქტორის ფუნქციის გამოყენებით (როგორც პირი თქვენს მაგალითში), შეგიძლიათ დაამატოთ თვისებები და მეთოდები ამ კონსტრუქტორის ფუნქციის პროტოტიპში. ამ კონსტრუქტორის ფუნქციის გამოყენებით შექმნილი ნებისმიერი ობიექტი შემდეგ მემკვიდრეობით მიიღებს ამ თვისებებს და მეთოდებს მათი პროტოტიპის ჯაჭვის მეშვეობით.

თქვენს კოდში, Person.prototype.printInfo ამატებს printInfo მეთოდს Person კონსტრუქტორის ფუნქციის პროტოტიპს. ეს ნიშნავს, რომ Person კონსტრუქტორის გამოყენებით შექმნილ ნებისმიერ ობიექტს ექნება წვდომა printInfo მეთოდზე მათი პროტოტიპური ჯაჭვის მეშვეობით.

A namespace is used to organize code into logical groups and give them names.

So, the std namespace is part of the <iostream> header, containing the cout command.

class

კლასები არის ობიექტების შექმნის შაბლონი. ისინი ახდენენ მონაცემებს კოდით, რომ იმუშაონ ამ მონაცემებზე. კლასები JS-ში აგებულია პროტოტიპებზე, მაგრამ ასევე აქვთ გარკვეული სინტაქსი და სემანტიკა, რომელიც უნიკალურია კლასებისთვის. დამატებითი მაგალითებისა და განმარტებებისთვის იხილეთ კლასების გამოყენება სახელმძღვანელო.

call back

JavaScript ფუნქციები შესრულებულია იმ თანმიმდევრობით, რომელსაც ისინი უწოდებენ. არა იმ თანმიმდევრობით, რაც ისინი განისაზღვრება.

ამ მაგალითში გამოჩნდება "მშვიდობით":

function myFirst() {
  myDisplayer("Hello");
}

function mySecond() {
  myDisplayer("Goodbye");
}

myFirst();
mySecond();

ზოგჯერ გსურთ გქონდეთ უკეთესი კონტროლი ფუნქციის შესრულების დროს.

დავუშვათ, რომ გსურთ გააკეთოთ გაანგარიშება და შემდეგ აჩვენოთ შედეგი.

თქვენ შეგიძლიათ გამოიძახოთ კალკულატორის ფუნქცია (myCalculator), შეინახოთ შედეგი და შემდეგ გამოიძახოთ სხვა ფუნქცია (myDisplayer) შედეგის სანახავად:

function myDisplayer(some) {
  document.getElementById("demo").innerHTML = some;
}

function myCalculator(num1, num2) {
  let sum = num1 + num2;
  return sum;
}

let result = myCalculator(5, 5);
myDisplayer(result);